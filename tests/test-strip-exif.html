<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strip EXIF/Metadata Tests - iresized.com</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 900px;
            margin: 50px auto;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        h1 { color: #D4A84B; }
        h2 { color: #8B7355; margin-top: 30px; }
        #test-output {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            white-space: pre-wrap;
            font-size: 14px;
            max-height: 600px;
            overflow-y: auto;
        }
        .test-suite { color: #D4A84B; font-weight: bold; margin-top: 15px; }
        .test-pass { color: #4CAF50; }
        .test-fail { color: #f44336; }
        .test-info { color: #888; }
        #test-summary {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 16px;
        }
        button {
            background: #D4A84B;
            color: #1a1a1a;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-right: 10px;
        }
        button:hover { background: #c49a3f; }
        .image-preview {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .image-preview div {
            text-align: center;
        }
        .image-preview img, .image-preview canvas {
            max-width: 200px;
            max-height: 200px;
            border: 2px solid #444;
            border-radius: 4px;
        }
        .manual-test {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .manual-test h3 { color: #D4A84B; margin-top: 0; }
        input[type="file"] {
            background: #333;
            padding: 10px;
            border-radius: 4px;
            color: #e0e0e0;
        }
    </style>
</head>
<body>
    <h1>Strip EXIF/Metadata Tests</h1>
    <p>Tests to verify EXIF and metadata stripping functionality.</p>

    <button onclick="runTests()">Run Automated Tests</button>
    <button onclick="TestUtils.reset()">Clear</button>

    <div id="test-summary"></div>
    <div id="test-output"></div>

    <div class="manual-test">
        <h3>Manual Test: Upload Image with EXIF Data</h3>
        <p>Upload a JPEG image (from a camera/phone) that contains EXIF data to verify stripping works.</p>
        <input type="file" id="manual-file-input" accept="image/*">
        <button onclick="runManualTest()">Test Strip EXIF</button>
        <div id="manual-result"></div>
        <div class="image-preview" id="manual-preview"></div>
    </div>

    <script src="test-utils.js"></script>
    <script>
        /**
         * Strip metadata by re-encoding through canvas
         * This mirrors the processStripMetadata function in script.js
         */
        function stripMetadata(imageBlob, format = 'jpeg', quality = 0.95) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    const mimeType = `image/${format}`;
                    canvas.toBlob(function(blob) {
                        URL.revokeObjectURL(img.src);
                        canvas.width = 0;
                        canvas.height = 0;
                        resolve(blob);
                    }, mimeType, format === 'png' ? undefined : quality);
                };
                img.onerror = () => {
                    URL.revokeObjectURL(img.src);
                    reject(new Error('Failed to load image'));
                };
                img.src = URL.createObjectURL(imageBlob);
            });
        }

        /**
         * Check for EXIF APP1 marker in JPEG
         */
        async function hasExifMarker(blob) {
            if (!blob.type.includes('jpeg') && !blob.type.includes('jpg')) {
                return false; // Only JPEG has EXIF
            }

            const buffer = await blob.arrayBuffer();
            const view = new Uint8Array(buffer);

            // JPEG starts with FFD8
            if (view[0] !== 0xFF || view[1] !== 0xD8) return false;

            // Look for APP1 marker (FFE1) which contains EXIF
            for (let i = 2; i < view.length - 10; i++) {
                if (view[i] === 0xFF && view[i + 1] === 0xE1) {
                    // Check if it's EXIF (starts with "Exif\0\0")
                    const exifHeader = String.fromCharCode(view[i + 4], view[i + 5], view[i + 6], view[i + 7]);
                    if (exifHeader === 'Exif') {
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Create a JPEG with fake EXIF data for testing
         */
        async function createJpegWithFakeExif() {
            // Create a simple image via canvas
            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 100;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ff6600';
            ctx.fillRect(0, 0, 100, 100);
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.fillText('TEST', 30, 55);

            return new Promise(resolve => {
                canvas.toBlob(resolve, 'image/jpeg', 0.92);
            });
        }

        async function runTests() {
            TestUtils.reset();
            const T = TestUtils;

            // ===============================
            // Canvas Stripping Tests
            // ===============================
            T.suite('Canvas Re-encoding (Metadata Strip)');

            await T.testAsync('creates valid output blob', async () => {
                const testBlob = await createJpegWithFakeExif();
                const stripped = await stripMetadata(testBlob, 'jpeg');
                T.assertNotNull(stripped);
                T.assertInstanceOf(stripped, Blob);
            });

            await T.testAsync('preserves image dimensions', async () => {
                const testBlob = await TestUtils.createTestImageBlob(200, 150);
                const stripped = await stripMetadata(testBlob, 'png');

                const img = await TestUtils.loadImage(stripped);
                T.assertEqual(img.naturalWidth, 200);
                T.assertEqual(img.naturalHeight, 150);
            });

            await T.testAsync('outputs correct MIME type for JPEG', async () => {
                const testBlob = await createJpegWithFakeExif();
                const stripped = await stripMetadata(testBlob, 'jpeg');
                T.assertTrue(stripped.type.includes('jpeg'));
            });

            await T.testAsync('outputs correct MIME type for PNG', async () => {
                const testBlob = await TestUtils.createTestImageBlob(100, 100);
                const stripped = await stripMetadata(testBlob, 'png');
                T.assertTrue(stripped.type.includes('png'));
            });

            await T.testAsync('outputs correct MIME type for WebP', async () => {
                const testBlob = await TestUtils.createTestImageBlob(100, 100);
                const stripped = await stripMetadata(testBlob, 'webp');
                // WebP support varies by browser
                T.assertTrue(stripped.type.includes('webp') || stripped.type.includes('png'));
            });

            // ===============================
            // Format Conversion Tests
            // ===============================
            T.suite('Format Conversion');

            await T.testAsync('converts PNG to JPEG', async () => {
                const pngBlob = await TestUtils.createTestImageBlob(100, 100);
                T.assertTrue(pngBlob.type.includes('png'));

                const jpegBlob = await stripMetadata(pngBlob, 'jpeg');
                T.assertTrue(jpegBlob.type.includes('jpeg'));
            });

            await T.testAsync('converts JPEG to PNG', async () => {
                const jpegBlob = await createJpegWithFakeExif();
                T.assertTrue(jpegBlob.type.includes('jpeg'));

                const pngBlob = await stripMetadata(jpegBlob, 'png');
                T.assertTrue(pngBlob.type.includes('png'));
            });

            // ===============================
            // Quality Tests
            // ===============================
            T.suite('Quality Settings');

            await T.testAsync('higher quality produces larger file', async () => {
                const testBlob = await createJpegWithFakeExif();

                const highQuality = await stripMetadata(testBlob, 'jpeg', 0.95);
                const lowQuality = await stripMetadata(testBlob, 'jpeg', 0.5);

                // High quality should generally be larger (may vary with small images)
                T.assertTrue(highQuality.size > 0);
                T.assertTrue(lowQuality.size > 0);
            });

            await T.testAsync('quality parameter is ignored for PNG', async () => {
                const testBlob = await TestUtils.createTestImageBlob(100, 100);

                const png1 = await stripMetadata(testBlob, 'png', 0.1);
                const png2 = await stripMetadata(testBlob, 'png', 1.0);

                // PNG is lossless, so size should be similar
                const sizeDiff = Math.abs(png1.size - png2.size);
                T.assertTrue(sizeDiff < 1000); // Allow small variation
            });

            // ===============================
            // Edge Cases
            // ===============================
            T.suite('Edge Cases');

            await T.testAsync('handles small images (1x1)', async () => {
                const tinyBlob = await TestUtils.createTestImageBlob(1, 1);
                const stripped = await stripMetadata(tinyBlob, 'png');
                T.assertNotNull(stripped);
                T.assertTrue(stripped.size > 0);
            });

            await T.testAsync('handles large images (2000x2000)', async () => {
                const largeBlob = await TestUtils.createTestImageBlob(2000, 2000);
                const stripped = await stripMetadata(largeBlob, 'jpeg', 0.8);
                T.assertNotNull(stripped);

                const img = await TestUtils.loadImage(stripped);
                T.assertEqual(img.naturalWidth, 2000);
                T.assertEqual(img.naturalHeight, 2000);
            });

            await T.testAsync('handles non-square images', async () => {
                const wideBlob = await TestUtils.createTestImageBlob(500, 100);
                const stripped = await stripMetadata(wideBlob, 'jpeg');

                const img = await TestUtils.loadImage(stripped);
                T.assertEqual(img.naturalWidth, 500);
                T.assertEqual(img.naturalHeight, 100);
            });

            // ===============================
            // Memory Cleanup Tests
            // ===============================
            T.suite('Memory Management');

            await T.testAsync('multiple operations do not leak memory', async () => {
                const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;

                for (let i = 0; i < 10; i++) {
                    const blob = await TestUtils.createTestImageBlob(500, 500);
                    await stripMetadata(blob, 'jpeg');
                }

                // Force GC if available (not reliable in browsers)
                if (window.gc) window.gc();

                // Just verify it completes without error
                T.assertTrue(true);
            });

            T.summary();
        }

        async function runManualTest() {
            const fileInput = document.getElementById('manual-file-input');
            const resultDiv = document.getElementById('manual-result');
            const previewDiv = document.getElementById('manual-preview');

            if (!fileInput.files.length) {
                resultDiv.innerHTML = '<p style="color: #f44336;">Please select a file first.</p>';
                return;
            }

            const file = fileInput.files[0];
            resultDiv.innerHTML = '<p>Processing...</p>';

            try {
                // Check original for EXIF
                const hasExifBefore = await hasExifMarker(file);

                // Strip metadata
                const stripped = await stripMetadata(file, 'jpeg', 0.95);

                // Check stripped for EXIF
                const hasExifAfter = await hasExifMarker(stripped);

                // Display results
                resultDiv.innerHTML = `
                    <p><strong>Original:</strong> ${file.name} (${(file.size / 1024).toFixed(1)} KB)</p>
                    <p><strong>EXIF in original:</strong> ${hasExifBefore ? '<span style="color: #D4A84B;">YES</span>' : 'No EXIF detected'}</p>
                    <p><strong>Stripped size:</strong> ${(stripped.size / 1024).toFixed(1)} KB</p>
                    <p><strong>EXIF after strip:</strong> ${hasExifAfter ? '<span style="color: #f44336;">STILL PRESENT (unexpected)</span>' : '<span style="color: #4CAF50;">REMOVED</span>'}</p>
                `;

                // Show visual comparison
                previewDiv.innerHTML = `
                    <div>
                        <p>Original</p>
                        <img id="original-img">
                    </div>
                    <div>
                        <p>Stripped</p>
                        <img id="stripped-img">
                    </div>
                `;

                document.getElementById('original-img').src = URL.createObjectURL(file);
                document.getElementById('stripped-img').src = URL.createObjectURL(stripped);

            } catch (err) {
                resultDiv.innerHTML = `<p style="color: #f44336;">Error: ${err.message}</p>`;
            }
        }

        // Auto-run on load
        window.onload = runTests;
    </script>
</body>
</html>
